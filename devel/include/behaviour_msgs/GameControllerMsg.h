// Generated by gencpp from file behaviour_msgs/GameControllerMsg.msg
// DO NOT EDIT!


#ifndef BEHAVIOUR_MSGS_MESSAGE_GAMECONTROLLERMSG_H
#define BEHAVIOUR_MSGS_MESSAGE_GAMECONTROLLERMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <behaviour_msgs/GameControllerTeamMsg.h>

namespace behaviour_msgs
{
template <class ContainerAllocator>
struct GameControllerMsg_
{
  typedef GameControllerMsg_<ContainerAllocator> Type;

  GameControllerMsg_()
    : header()
    , version(0)
    , packetNumber(0)
    , playersPerTeam(0)
    , gamePhase(0)
    , state(0)
    , setPlay(0)
    , firstHalf(0)
    , kickingTeam(0)
    , dropInTeam(0)
    , dropInTime(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , teams()  {
    }
  GameControllerMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , version(0)
    , packetNumber(0)
    , playersPerTeam(0)
    , gamePhase(0)
    , state(0)
    , setPlay(0)
    , firstHalf(0)
    , kickingTeam(0)
    , dropInTeam(0)
    , dropInTime(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , teams(_alloc)  {
  (void)_alloc;
    }



   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _header_type;
  _header_type header;

   typedef uint16_t _version_type;
  _version_type version;

   typedef uint8_t _packetNumber_type;
  _packetNumber_type packetNumber;

   typedef uint8_t _playersPerTeam_type;
  _playersPerTeam_type playersPerTeam;

   typedef uint8_t _gamePhase_type;
  _gamePhase_type gamePhase;

   typedef uint8_t _state_type;
  _state_type state;

   typedef uint8_t _setPlay_type;
  _setPlay_type setPlay;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _kickingTeam_type;
  _kickingTeam_type kickingTeam;

   typedef uint8_t _dropInTeam_type;
  _dropInTeam_type dropInTeam;

   typedef uint16_t _dropInTime_type;
  _dropInTime_type dropInTime;

   typedef uint16_t _secsRemaining_type;
  _secsRemaining_type secsRemaining;

   typedef uint16_t _secondaryTime_type;
  _secondaryTime_type secondaryTime;

   typedef std::vector< ::behaviour_msgs::GameControllerTeamMsg_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::behaviour_msgs::GameControllerTeamMsg_<ContainerAllocator> >::other >  _teams_type;
  _teams_type teams;





  typedef boost::shared_ptr< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> const> ConstPtr;

}; // struct GameControllerMsg_

typedef ::behaviour_msgs::GameControllerMsg_<std::allocator<void> > GameControllerMsg;

typedef boost::shared_ptr< ::behaviour_msgs::GameControllerMsg > GameControllerMsgPtr;
typedef boost::shared_ptr< ::behaviour_msgs::GameControllerMsg const> GameControllerMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator1> & lhs, const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.version == rhs.version &&
    lhs.packetNumber == rhs.packetNumber &&
    lhs.playersPerTeam == rhs.playersPerTeam &&
    lhs.gamePhase == rhs.gamePhase &&
    lhs.state == rhs.state &&
    lhs.setPlay == rhs.setPlay &&
    lhs.firstHalf == rhs.firstHalf &&
    lhs.kickingTeam == rhs.kickingTeam &&
    lhs.dropInTeam == rhs.dropInTeam &&
    lhs.dropInTime == rhs.dropInTime &&
    lhs.secsRemaining == rhs.secsRemaining &&
    lhs.secondaryTime == rhs.secondaryTime &&
    lhs.teams == rhs.teams;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator1> & lhs, const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace behaviour_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e78b2067609ba5f0cc69e8cda68a5fce";
  }

  static const char* value(const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe78b2067609ba5f0ULL;
  static const uint64_t static_value2 = 0xcc69e8cda68a5fceULL;
};

template<class ContainerAllocator>
struct DataType< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "behaviour_msgs/GameControllerMsg";
  }

  static const char* value(const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint8[] header              \n"
"uint16 version           \n"
"uint8 packetNumber        \n"
"uint8 playersPerTeam      \n"
"uint8 gamePhase             \n"
"uint8 state    \n"
"uint8 setPlay           \n"
"uint8 firstHalf            \n"
"uint8 kickingTeam\n"
"uint8 dropInTeam           \n"
"uint16 dropInTime          \n"
"uint16 secsRemaining      \n"
"uint16 secondaryTime      \n"
"GameControllerTeamMsg[] teams\n"
"\n"
"================================================================================\n"
"MSG: behaviour_msgs/GameControllerTeamMsg\n"
"uint8 teamNumber\n"
"uint8 teamColour\n"
"GameControllerPlayerMsg[] players\n"
"================================================================================\n"
"MSG: behaviour_msgs/GameControllerPlayerMsg\n"
"uint8 penalty\n"
"uint8 secsTillUnpenalised\n"
;
  }

  static const char* value(const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.version);
      stream.next(m.packetNumber);
      stream.next(m.playersPerTeam);
      stream.next(m.gamePhase);
      stream.next(m.state);
      stream.next(m.setPlay);
      stream.next(m.firstHalf);
      stream.next(m.kickingTeam);
      stream.next(m.dropInTeam);
      stream.next(m.dropInTime);
      stream.next(m.secsRemaining);
      stream.next(m.secondaryTime);
      stream.next(m.teams);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GameControllerMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::behaviour_msgs::GameControllerMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::behaviour_msgs::GameControllerMsg_<ContainerAllocator>& v)
  {
    s << indent << "header[]" << std::endl;
    for (size_t i = 0; i < v.header.size(); ++i)
    {
      s << indent << "  header[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.header[i]);
    }
    s << indent << "version: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.version);
    s << indent << "packetNumber: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.packetNumber);
    s << indent << "playersPerTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.playersPerTeam);
    s << indent << "gamePhase: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gamePhase);
    s << indent << "state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state);
    s << indent << "setPlay: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.setPlay);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "kickingTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.kickingTeam);
    s << indent << "dropInTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dropInTeam);
    s << indent << "dropInTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dropInTime);
    s << indent << "secsRemaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secsRemaining);
    s << indent << "secondaryTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondaryTime);
    s << indent << "teams[]" << std::endl;
    for (size_t i = 0; i < v.teams.size(); ++i)
    {
      s << indent << "  teams[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::behaviour_msgs::GameControllerTeamMsg_<ContainerAllocator> >::stream(s, indent + "    ", v.teams[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEHAVIOUR_MSGS_MESSAGE_GAMECONTROLLERMSG_H
