// Generated by gencpp from file behaviour_msgs/GameState.msg
// DO NOT EDIT!


#ifndef BEHAVIOUR_MSGS_MESSAGE_GAMESTATE_H
#define BEHAVIOUR_MSGS_MESSAGE_GAMESTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace behaviour_msgs
{
template <class ContainerAllocator>
struct GameState_
{
  typedef GameState_<ContainerAllocator> Type;

  GameState_()
    : header()
    , gameState(0)
    , secondaryState(0)
    , secondaryStateTeam(0)
    , secondaryStateMode(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , teamColor(0)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message()
    , teamMatesWithPenalty()
    , teamMatesWithRedCard()  {
    }
  GameState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , gameState(0)
    , secondaryState(0)
    , secondaryStateTeam(0)
    , secondaryStateMode(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , teamColor(0)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message(_alloc)
    , teamMatesWithPenalty(_alloc)
    , teamMatesWithRedCard(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _gameState_type;
  _gameState_type gameState;

   typedef uint8_t _secondaryState_type;
  _secondaryState_type secondaryState;

   typedef uint8_t _secondaryStateTeam_type;
  _secondaryStateTeam_type secondaryStateTeam;

   typedef uint8_t _secondaryStateMode_type;
  _secondaryStateMode_type secondaryStateMode;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _ownScore_type;
  _ownScore_type ownScore;

   typedef uint8_t _rivalScore_type;
  _rivalScore_type rivalScore;

   typedef int16_t _secondsRemaining_type;
  _secondsRemaining_type secondsRemaining;

   typedef int16_t _secondary_seconds_remaining_type;
  _secondary_seconds_remaining_type secondary_seconds_remaining;

   typedef uint8_t _hasKickOff_type;
  _hasKickOff_type hasKickOff;

   typedef uint8_t _penalized_type;
  _penalized_type penalized;

   typedef uint16_t _secondsTillUnpenalized_type;
  _secondsTillUnpenalized_type secondsTillUnpenalized;

   typedef uint8_t _teamColor_type;
  _teamColor_type teamColor;

   typedef uint8_t _dropInTeam_type;
  _dropInTeam_type dropInTeam;

   typedef uint16_t _dropInTime_type;
  _dropInTime_type dropInTime;

   typedef uint8_t _penaltyShot_type;
  _penaltyShot_type penaltyShot;

   typedef uint16_t _singleShots_type;
  _singleShots_type singleShots;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _coach_message_type;
  _coach_message_type coach_message;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _teamMatesWithPenalty_type;
  _teamMatesWithPenalty_type teamMatesWithPenalty;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _teamMatesWithRedCard_type;
  _teamMatesWithRedCard_type teamMatesWithRedCard;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(GAMESTATE_INITAL)
  #undef GAMESTATE_INITAL
#endif
#if defined(_WIN32) && defined(GAMESTATE_READY)
  #undef GAMESTATE_READY
#endif
#if defined(_WIN32) && defined(GAMESTATE_SET)
  #undef GAMESTATE_SET
#endif
#if defined(_WIN32) && defined(GAMESTATE_PLAYING)
  #undef GAMESTATE_PLAYING
#endif
#if defined(_WIN32) && defined(GAMESTATE_FINISHED)
  #undef GAMESTATE_FINISHED
#endif
#if defined(_WIN32) && defined(STATE_NORMAL)
  #undef STATE_NORMAL
#endif
#if defined(_WIN32) && defined(STATE_PENALTYSHOOT)
  #undef STATE_PENALTYSHOOT
#endif
#if defined(_WIN32) && defined(STATE_OVERTIME)
  #undef STATE_OVERTIME
#endif
#if defined(_WIN32) && defined(STATE_TIMEOUT)
  #undef STATE_TIMEOUT
#endif
#if defined(_WIN32) && defined(STATE_DIRECT_FREEKICK)
  #undef STATE_DIRECT_FREEKICK
#endif
#if defined(_WIN32) && defined(STATE_INDIRECT_FREEKICK)
  #undef STATE_INDIRECT_FREEKICK
#endif
#if defined(_WIN32) && defined(STATE_PENALTYKICK)
  #undef STATE_PENALTYKICK
#endif
#if defined(_WIN32) && defined(STATE_CORNER_KICK)
  #undef STATE_CORNER_KICK
#endif
#if defined(_WIN32) && defined(STATE_GOAL_KICK)
  #undef STATE_GOAL_KICK
#endif
#if defined(_WIN32) && defined(STATE_THROW_IN)
  #undef STATE_THROW_IN
#endif
#if defined(_WIN32) && defined(MODE_PREPARATION)
  #undef MODE_PREPARATION
#endif
#if defined(_WIN32) && defined(MODE_PLACING)
  #undef MODE_PLACING
#endif
#if defined(_WIN32) && defined(MODE_END)
  #undef MODE_END
#endif
#if defined(_WIN32) && defined(BLUE)
  #undef BLUE
#endif
#if defined(_WIN32) && defined(RED)
  #undef RED
#endif

  enum {
    GAMESTATE_INITAL = 0u,
    GAMESTATE_READY = 1u,
    GAMESTATE_SET = 2u,
    GAMESTATE_PLAYING = 3u,
    GAMESTATE_FINISHED = 4u,
    STATE_NORMAL = 0u,
    STATE_PENALTYSHOOT = 1u,
    STATE_OVERTIME = 2u,
    STATE_TIMEOUT = 3u,
    STATE_DIRECT_FREEKICK = 4u,
    STATE_INDIRECT_FREEKICK = 5u,
    STATE_PENALTYKICK = 6u,
    STATE_CORNER_KICK = 7u,
    STATE_GOAL_KICK = 8u,
    STATE_THROW_IN = 9u,
    MODE_PREPARATION = 0u,
    MODE_PLACING = 1u,
    MODE_END = 2u,
    BLUE = 0u,
    RED = 1u,
  };


  typedef boost::shared_ptr< ::behaviour_msgs::GameState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::behaviour_msgs::GameState_<ContainerAllocator> const> ConstPtr;

}; // struct GameState_

typedef ::behaviour_msgs::GameState_<std::allocator<void> > GameState;

typedef boost::shared_ptr< ::behaviour_msgs::GameState > GameStatePtr;
typedef boost::shared_ptr< ::behaviour_msgs::GameState const> GameStateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::behaviour_msgs::GameState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::behaviour_msgs::GameState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::behaviour_msgs::GameState_<ContainerAllocator1> & lhs, const ::behaviour_msgs::GameState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.gameState == rhs.gameState &&
    lhs.secondaryState == rhs.secondaryState &&
    lhs.secondaryStateTeam == rhs.secondaryStateTeam &&
    lhs.secondaryStateMode == rhs.secondaryStateMode &&
    lhs.firstHalf == rhs.firstHalf &&
    lhs.ownScore == rhs.ownScore &&
    lhs.rivalScore == rhs.rivalScore &&
    lhs.secondsRemaining == rhs.secondsRemaining &&
    lhs.secondary_seconds_remaining == rhs.secondary_seconds_remaining &&
    lhs.hasKickOff == rhs.hasKickOff &&
    lhs.penalized == rhs.penalized &&
    lhs.secondsTillUnpenalized == rhs.secondsTillUnpenalized &&
    lhs.teamColor == rhs.teamColor &&
    lhs.dropInTeam == rhs.dropInTeam &&
    lhs.dropInTime == rhs.dropInTime &&
    lhs.penaltyShot == rhs.penaltyShot &&
    lhs.singleShots == rhs.singleShots &&
    lhs.coach_message == rhs.coach_message &&
    lhs.teamMatesWithPenalty == rhs.teamMatesWithPenalty &&
    lhs.teamMatesWithRedCard == rhs.teamMatesWithRedCard;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::behaviour_msgs::GameState_<ContainerAllocator1> & lhs, const ::behaviour_msgs::GameState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace behaviour_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::GameState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::GameState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::GameState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::GameState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::behaviour_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "05e642bcc57ff44405bdd1bd88b89292";
  }

  static const char* value(const ::behaviour_msgs::GameState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x05e642bcc57ff444ULL;
  static const uint64_t static_value2 = 0x05bdd1bd88b89292ULL;
};

template<class ContainerAllocator>
struct DataType< ::behaviour_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "behaviour_msgs/GameState";
  }

  static const char* value(const ::behaviour_msgs::GameState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::behaviour_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"\n"
"uint8 GAMESTATE_INITAL=0\n"
"uint8 GAMESTATE_READY=1\n"
"uint8 GAMESTATE_SET=2\n"
"uint8 GAMESTATE_PLAYING=3\n"
"uint8 GAMESTATE_FINISHED=4\n"
"uint8 gameState\n"
"\n"
"# Secondary state, penaltyshoot is penalty shootout at the end of the game,\n"
"# penaltykick is a kick during the game\n"
"uint8 STATE_NORMAL = 0\n"
"uint8 STATE_PENALTYSHOOT = 1\n"
"uint8 STATE_OVERTIME = 2\n"
"uint8 STATE_TIMEOUT = 3\n"
"uint8 STATE_DIRECT_FREEKICK = 4\n"
"uint8 STATE_INDIRECT_FREEKICK = 5\n"
"uint8 STATE_PENALTYKICK = 6\n"
"uint8 STATE_CORNER_KICK = 7\n"
"uint8 STATE_GOAL_KICK = 8\n"
"uint8 STATE_THROW_IN = 9\n"
"uint8 secondaryState\n"
"\n"
"# For newest version of game controller\n"
"# Tells which team has the free kick or penalty kick\n"
"uint8 secondaryStateTeam\n"
"# The secondary state contains a sub mode in which phase of execution the secondary state is\n"
"uint8 MODE_PREPARATION = 0\n"
"uint8 MODE_PLACING = 1\n"
"uint8 MODE_END = 2\n"
"uint8 secondaryStateMode\n"
"\n"
"bool firstHalf\n"
"uint8 ownScore\n"
"uint8 rivalScore\n"
"\n"
"# Seconds remaining for the game half\n"
"int16 secondsRemaining\n"
"# Seconds remaining for things like kickoff\n"
"int16 secondary_seconds_remaining\n"
"\n"
"bool hasKickOff\n"
"bool penalized\n"
"uint16 secondsTillUnpenalized\n"
"\n"
"# Team colors\n"
"uint8 BLUE = 0\n"
"uint8 RED = 1\n"
"uint8 teamColor\n"
"\n"
"bool dropInTeam\n"
"uint16 dropInTime\n"
"\n"
"# The number of the current penalty shot during penalty shootout\n"
"uint8 penaltyShot\n"
"# a binary pattern indicating the successful penalty shots (1 for successful, 0 for unsuccessful)\n"
"uint16 singleShots\n"
"\n"
"string coach_message\n"
"\n"
"bool[] teamMatesWithPenalty\n"
"bool[] teamMatesWithRedCard\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::behaviour_msgs::GameState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::behaviour_msgs::GameState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.gameState);
      stream.next(m.secondaryState);
      stream.next(m.secondaryStateTeam);
      stream.next(m.secondaryStateMode);
      stream.next(m.firstHalf);
      stream.next(m.ownScore);
      stream.next(m.rivalScore);
      stream.next(m.secondsRemaining);
      stream.next(m.secondary_seconds_remaining);
      stream.next(m.hasKickOff);
      stream.next(m.penalized);
      stream.next(m.secondsTillUnpenalized);
      stream.next(m.teamColor);
      stream.next(m.dropInTeam);
      stream.next(m.dropInTime);
      stream.next(m.penaltyShot);
      stream.next(m.singleShots);
      stream.next(m.coach_message);
      stream.next(m.teamMatesWithPenalty);
      stream.next(m.teamMatesWithRedCard);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GameState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::behaviour_msgs::GameState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::behaviour_msgs::GameState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "gameState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gameState);
    s << indent << "secondaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryState);
    s << indent << "secondaryStateTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryStateTeam);
    s << indent << "secondaryStateMode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryStateMode);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "ownScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ownScore);
    s << indent << "rivalScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rivalScore);
    s << indent << "secondsRemaining: ";
    Printer<int16_t>::stream(s, indent + "  ", v.secondsRemaining);
    s << indent << "secondary_seconds_remaining: ";
    Printer<int16_t>::stream(s, indent + "  ", v.secondary_seconds_remaining);
    s << indent << "hasKickOff: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hasKickOff);
    s << indent << "penalized: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalized);
    s << indent << "secondsTillUnpenalized: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondsTillUnpenalized);
    s << indent << "teamColor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.teamColor);
    s << indent << "dropInTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dropInTeam);
    s << indent << "dropInTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dropInTime);
    s << indent << "penaltyShot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penaltyShot);
    s << indent << "singleShots: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.singleShots);
    s << indent << "coach_message: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.coach_message);
    s << indent << "teamMatesWithPenalty[]" << std::endl;
    for (size_t i = 0; i < v.teamMatesWithPenalty.size(); ++i)
    {
      s << indent << "  teamMatesWithPenalty[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.teamMatesWithPenalty[i]);
    }
    s << indent << "teamMatesWithRedCard[]" << std::endl;
    for (size_t i = 0; i < v.teamMatesWithRedCard.size(); ++i)
    {
      s << indent << "  teamMatesWithRedCard[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.teamMatesWithRedCard[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEHAVIOUR_MSGS_MESSAGE_GAMESTATE_H
