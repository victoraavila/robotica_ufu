// Generated by gencpp from file behaviour_msgs/StateMachineActionsMsg.msg
// DO NOT EDIT!


#ifndef BEHAVIOUR_MSGS_MESSAGE_STATEMACHINEACTIONSMSG_H
#define BEHAVIOUR_MSGS_MESSAGE_STATEMACHINEACTIONSMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace behaviour_msgs
{
template <class ContainerAllocator>
struct StateMachineActionsMsg_
{
  typedef StateMachineActionsMsg_<ContainerAllocator> Type;

  StateMachineActionsMsg_()
    : falling(false)
    , finish_kicking(false)
    , searching(false)
    , ball(false)
    , ball_close(false)
    , ball_centered(false)
    , moving(false)
    , game_controller(false)
    , getting_up(false)
    , impossible(false)  {
    }
  StateMachineActionsMsg_(const ContainerAllocator& _alloc)
    : falling(false)
    , finish_kicking(false)
    , searching(false)
    , ball(false)
    , ball_close(false)
    , ball_centered(false)
    , moving(false)
    , game_controller(false)
    , getting_up(false)
    , impossible(false)  {
  (void)_alloc;
    }



   typedef uint8_t _falling_type;
  _falling_type falling;

   typedef uint8_t _finish_kicking_type;
  _finish_kicking_type finish_kicking;

   typedef uint8_t _searching_type;
  _searching_type searching;

   typedef uint8_t _ball_type;
  _ball_type ball;

   typedef uint8_t _ball_close_type;
  _ball_close_type ball_close;

   typedef uint8_t _ball_centered_type;
  _ball_centered_type ball_centered;

   typedef uint8_t _moving_type;
  _moving_type moving;

   typedef uint8_t _game_controller_type;
  _game_controller_type game_controller;

   typedef uint8_t _getting_up_type;
  _getting_up_type getting_up;

   typedef uint8_t _impossible_type;
  _impossible_type impossible;





  typedef boost::shared_ptr< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> const> ConstPtr;

}; // struct StateMachineActionsMsg_

typedef ::behaviour_msgs::StateMachineActionsMsg_<std::allocator<void> > StateMachineActionsMsg;

typedef boost::shared_ptr< ::behaviour_msgs::StateMachineActionsMsg > StateMachineActionsMsgPtr;
typedef boost::shared_ptr< ::behaviour_msgs::StateMachineActionsMsg const> StateMachineActionsMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator1> & lhs, const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator2> & rhs)
{
  return lhs.falling == rhs.falling &&
    lhs.finish_kicking == rhs.finish_kicking &&
    lhs.searching == rhs.searching &&
    lhs.ball == rhs.ball &&
    lhs.ball_close == rhs.ball_close &&
    lhs.ball_centered == rhs.ball_centered &&
    lhs.moving == rhs.moving &&
    lhs.game_controller == rhs.game_controller &&
    lhs.getting_up == rhs.getting_up &&
    lhs.impossible == rhs.impossible;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator1> & lhs, const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace behaviour_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9252a10d7d533ef28cb83926994c2a51";
  }

  static const char* value(const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9252a10d7d533ef2ULL;
  static const uint64_t static_value2 = 0x8cb83926994c2a51ULL;
};

template<class ContainerAllocator>
struct DataType< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "behaviour_msgs/StateMachineActionsMsg";
  }

  static const char* value(const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool falling\n"
"bool finish_kicking \n"
"bool searching \n"
"bool ball \n"
"bool ball_close\n"
"bool ball_centered\n"
"bool moving \n"
"bool game_controller \n"
"bool getting_up \n"
"bool impossible\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.falling);
      stream.next(m.finish_kicking);
      stream.next(m.searching);
      stream.next(m.ball);
      stream.next(m.ball_close);
      stream.next(m.ball_centered);
      stream.next(m.moving);
      stream.next(m.game_controller);
      stream.next(m.getting_up);
      stream.next(m.impossible);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct StateMachineActionsMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::behaviour_msgs::StateMachineActionsMsg_<ContainerAllocator>& v)
  {
    s << indent << "falling: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.falling);
    s << indent << "finish_kicking: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.finish_kicking);
    s << indent << "searching: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.searching);
    s << indent << "ball: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ball);
    s << indent << "ball_close: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ball_close);
    s << indent << "ball_centered: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ball_centered);
    s << indent << "moving: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.moving);
    s << indent << "game_controller: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.game_controller);
    s << indent << "getting_up: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.getting_up);
    s << indent << "impossible: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.impossible);
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEHAVIOUR_MSGS_MESSAGE_STATEMACHINEACTIONSMSG_H
