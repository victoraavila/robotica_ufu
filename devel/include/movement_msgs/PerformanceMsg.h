// Generated by gencpp from file movement_msgs/PerformanceMsg.msg
// DO NOT EDIT!


#ifndef MOVEMENT_MSGS_MESSAGE_PERFORMANCEMSG_H
#define MOVEMENT_MSGS_MESSAGE_PERFORMANCEMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace movement_msgs
{
template <class ContainerAllocator>
struct PerformanceMsg_
{
  typedef PerformanceMsg_<ContainerAllocator> Type;

  PerformanceMsg_()
    : data()
    , bins()
    , freq(0.0)
    , amp(0.0)
    , mean(0.0)
    , integral(0.0)
    , freqRef(0.0)
    , freqRange(0.0)
    , ampRef(0.0)
    , ampRange(0.0)
    , meanRef(0.0)
    , meanRange(0.0)
    , freqPerf(0.0)
    , ampPerf(0.0)
    , meanPerf(0.0)
    , wFreq(0.0)
    , wAmp(0.0)
    , wMean(0.0)
    , perf(0.0)  {
    }
  PerformanceMsg_(const ContainerAllocator& _alloc)
    : data(_alloc)
    , bins(_alloc)
    , freq(0.0)
    , amp(0.0)
    , mean(0.0)
    , integral(0.0)
    , freqRef(0.0)
    , freqRange(0.0)
    , ampRef(0.0)
    , ampRange(0.0)
    , meanRef(0.0)
    , meanRange(0.0)
    , freqPerf(0.0)
    , ampPerf(0.0)
    , meanPerf(0.0)
    , wFreq(0.0)
    , wAmp(0.0)
    , wMean(0.0)
    , perf(0.0)  {
  (void)_alloc;
    }



   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _data_type;
  _data_type data;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _bins_type;
  _bins_type bins;

   typedef double _freq_type;
  _freq_type freq;

   typedef double _amp_type;
  _amp_type amp;

   typedef double _mean_type;
  _mean_type mean;

   typedef double _integral_type;
  _integral_type integral;

   typedef double _freqRef_type;
  _freqRef_type freqRef;

   typedef double _freqRange_type;
  _freqRange_type freqRange;

   typedef double _ampRef_type;
  _ampRef_type ampRef;

   typedef double _ampRange_type;
  _ampRange_type ampRange;

   typedef double _meanRef_type;
  _meanRef_type meanRef;

   typedef double _meanRange_type;
  _meanRange_type meanRange;

   typedef double _freqPerf_type;
  _freqPerf_type freqPerf;

   typedef double _ampPerf_type;
  _ampPerf_type ampPerf;

   typedef double _meanPerf_type;
  _meanPerf_type meanPerf;

   typedef double _wFreq_type;
  _wFreq_type wFreq;

   typedef double _wAmp_type;
  _wAmp_type wAmp;

   typedef double _wMean_type;
  _wMean_type wMean;

   typedef double _perf_type;
  _perf_type perf;





  typedef boost::shared_ptr< ::movement_msgs::PerformanceMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::movement_msgs::PerformanceMsg_<ContainerAllocator> const> ConstPtr;

}; // struct PerformanceMsg_

typedef ::movement_msgs::PerformanceMsg_<std::allocator<void> > PerformanceMsg;

typedef boost::shared_ptr< ::movement_msgs::PerformanceMsg > PerformanceMsgPtr;
typedef boost::shared_ptr< ::movement_msgs::PerformanceMsg const> PerformanceMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::movement_msgs::PerformanceMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::movement_msgs::PerformanceMsg_<ContainerAllocator1> & lhs, const ::movement_msgs::PerformanceMsg_<ContainerAllocator2> & rhs)
{
  return lhs.data == rhs.data &&
    lhs.bins == rhs.bins &&
    lhs.freq == rhs.freq &&
    lhs.amp == rhs.amp &&
    lhs.mean == rhs.mean &&
    lhs.integral == rhs.integral &&
    lhs.freqRef == rhs.freqRef &&
    lhs.freqRange == rhs.freqRange &&
    lhs.ampRef == rhs.ampRef &&
    lhs.ampRange == rhs.ampRange &&
    lhs.meanRef == rhs.meanRef &&
    lhs.meanRange == rhs.meanRange &&
    lhs.freqPerf == rhs.freqPerf &&
    lhs.ampPerf == rhs.ampPerf &&
    lhs.meanPerf == rhs.meanPerf &&
    lhs.wFreq == rhs.wFreq &&
    lhs.wAmp == rhs.wAmp &&
    lhs.wMean == rhs.wMean &&
    lhs.perf == rhs.perf;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::movement_msgs::PerformanceMsg_<ContainerAllocator1> & lhs, const ::movement_msgs::PerformanceMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace movement_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::movement_msgs::PerformanceMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::movement_msgs::PerformanceMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::movement_msgs::PerformanceMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "299aadea0ec447ab474d650cbedfd2a5";
  }

  static const char* value(const ::movement_msgs::PerformanceMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x299aadea0ec447abULL;
  static const uint64_t static_value2 = 0x474d650cbedfd2a5ULL;
};

template<class ContainerAllocator>
struct DataType< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "movement_msgs/PerformanceMsg";
  }

  static const char* value(const ::movement_msgs::PerformanceMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64[] data\n"
"float64[] bins\n"
"float64   freq\n"
"float64   amp\n"
"float64   mean\n"
"float64   integral\n"
"float64   freqRef\n"
"float64   freqRange\n"
"float64   ampRef\n"
"float64   ampRange\n"
"float64   meanRef\n"
"float64   meanRange\n"
"\n"
"float64   freqPerf\n"
"float64   ampPerf\n"
"float64   meanPerf\n"
"\n"
"float64   wFreq\n"
"float64   wAmp\n"
"float64   wMean\n"
"\n"
"float64   perf\n"
;
  }

  static const char* value(const ::movement_msgs::PerformanceMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.data);
      stream.next(m.bins);
      stream.next(m.freq);
      stream.next(m.amp);
      stream.next(m.mean);
      stream.next(m.integral);
      stream.next(m.freqRef);
      stream.next(m.freqRange);
      stream.next(m.ampRef);
      stream.next(m.ampRange);
      stream.next(m.meanRef);
      stream.next(m.meanRange);
      stream.next(m.freqPerf);
      stream.next(m.ampPerf);
      stream.next(m.meanPerf);
      stream.next(m.wFreq);
      stream.next(m.wAmp);
      stream.next(m.wMean);
      stream.next(m.perf);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PerformanceMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::movement_msgs::PerformanceMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::movement_msgs::PerformanceMsg_<ContainerAllocator>& v)
  {
    s << indent << "data[]" << std::endl;
    for (size_t i = 0; i < v.data.size(); ++i)
    {
      s << indent << "  data[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.data[i]);
    }
    s << indent << "bins[]" << std::endl;
    for (size_t i = 0; i < v.bins.size(); ++i)
    {
      s << indent << "  bins[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.bins[i]);
    }
    s << indent << "freq: ";
    Printer<double>::stream(s, indent + "  ", v.freq);
    s << indent << "amp: ";
    Printer<double>::stream(s, indent + "  ", v.amp);
    s << indent << "mean: ";
    Printer<double>::stream(s, indent + "  ", v.mean);
    s << indent << "integral: ";
    Printer<double>::stream(s, indent + "  ", v.integral);
    s << indent << "freqRef: ";
    Printer<double>::stream(s, indent + "  ", v.freqRef);
    s << indent << "freqRange: ";
    Printer<double>::stream(s, indent + "  ", v.freqRange);
    s << indent << "ampRef: ";
    Printer<double>::stream(s, indent + "  ", v.ampRef);
    s << indent << "ampRange: ";
    Printer<double>::stream(s, indent + "  ", v.ampRange);
    s << indent << "meanRef: ";
    Printer<double>::stream(s, indent + "  ", v.meanRef);
    s << indent << "meanRange: ";
    Printer<double>::stream(s, indent + "  ", v.meanRange);
    s << indent << "freqPerf: ";
    Printer<double>::stream(s, indent + "  ", v.freqPerf);
    s << indent << "ampPerf: ";
    Printer<double>::stream(s, indent + "  ", v.ampPerf);
    s << indent << "meanPerf: ";
    Printer<double>::stream(s, indent + "  ", v.meanPerf);
    s << indent << "wFreq: ";
    Printer<double>::stream(s, indent + "  ", v.wFreq);
    s << indent << "wAmp: ";
    Printer<double>::stream(s, indent + "  ", v.wAmp);
    s << indent << "wMean: ";
    Printer<double>::stream(s, indent + "  ", v.wMean);
    s << indent << "perf: ";
    Printer<double>::stream(s, indent + "  ", v.perf);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MOVEMENT_MSGS_MESSAGE_PERFORMANCEMSG_H
