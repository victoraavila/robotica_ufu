# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from movement_msgs/LearningMsg.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import movement_msgs.msg
import sensor_msgs.msg
import std_msgs.msg

class LearningMsg(genpy.Message):
  _md5sum = "bb9643324c03e2d257aa2412b115318f"
  _type = "movement_msgs/LearningMsg"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header    header
movement_msgs/PerformanceMsg x
movement_msgs/PerformanceMsg y
movement_msgs/PerformanceMsg z
movement_msgs/PerformanceMsg rFoot
movement_msgs/PerformanceMsg lFoot

float64[]           force
float64[]           torque3
float64[]           torque4
float64[]           torqueF
sensor_msgs/Imu[]   imu

float64   perf
float64   df
movement_msgs/HumanoidStateMsg  state


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: movement_msgs/PerformanceMsg
float64[] data
float64[] bins
float64   freq
float64   amp
float64   mean
float64   integral
float64   freqRef
float64   freqRange
float64   ampRef
float64   ampRange
float64   meanRef
float64   meanRange

float64   freqPerf
float64   ampPerf
float64   meanPerf

float64   wFreq
float64   wAmp
float64   wMean

float64   perf

================================================================================
MSG: sensor_msgs/Imu
# This is a message to hold data from an IMU (Inertial Measurement Unit)
#
# Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec
#
# If the covariance of the measurement is known, it should be filled in (if all you know is the 
# variance of each measurement, e.g. from the datasheet, just put those along the diagonal)
# A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the
# data a covariance will have to be assumed or gotten from some other source
#
# If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation 
# estimate), please set element 0 of the associated covariance matrix to -1
# If you are interpreting this message, please check for a value of -1 in the first element of each 
# covariance matrix, and disregard the associated estimate.

Header header

geometry_msgs/Quaternion orientation
float64[9] orientation_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 angular_velocity
float64[9] angular_velocity_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 linear_acceleration
float64[9] linear_acceleration_covariance # Row major x, y z 

================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: movement_msgs/HumanoidStateMsg
float64 angX
float64 angY

float64 gyroX
float64 gyroY
float64 gyroZ

float64 accX
float64 accY
float64 accZ
"""
  __slots__ = ['header','x','y','z','rFoot','lFoot','force','torque3','torque4','torqueF','imu','perf','df','state']
  _slot_types = ['std_msgs/Header','movement_msgs/PerformanceMsg','movement_msgs/PerformanceMsg','movement_msgs/PerformanceMsg','movement_msgs/PerformanceMsg','movement_msgs/PerformanceMsg','float64[]','float64[]','float64[]','float64[]','sensor_msgs/Imu[]','float64','float64','movement_msgs/HumanoidStateMsg']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,x,y,z,rFoot,lFoot,force,torque3,torque4,torqueF,imu,perf,df,state

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(LearningMsg, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.x is None:
        self.x = movement_msgs.msg.PerformanceMsg()
      if self.y is None:
        self.y = movement_msgs.msg.PerformanceMsg()
      if self.z is None:
        self.z = movement_msgs.msg.PerformanceMsg()
      if self.rFoot is None:
        self.rFoot = movement_msgs.msg.PerformanceMsg()
      if self.lFoot is None:
        self.lFoot = movement_msgs.msg.PerformanceMsg()
      if self.force is None:
        self.force = []
      if self.torque3 is None:
        self.torque3 = []
      if self.torque4 is None:
        self.torque4 = []
      if self.torqueF is None:
        self.torqueF = []
      if self.imu is None:
        self.imu = []
      if self.perf is None:
        self.perf = 0.
      if self.df is None:
        self.df = 0.
      if self.state is None:
        self.state = movement_msgs.msg.HumanoidStateMsg()
    else:
      self.header = std_msgs.msg.Header()
      self.x = movement_msgs.msg.PerformanceMsg()
      self.y = movement_msgs.msg.PerformanceMsg()
      self.z = movement_msgs.msg.PerformanceMsg()
      self.rFoot = movement_msgs.msg.PerformanceMsg()
      self.lFoot = movement_msgs.msg.PerformanceMsg()
      self.force = []
      self.torque3 = []
      self.torque4 = []
      self.torqueF = []
      self.imu = []
      self.perf = 0.
      self.df = 0.
      self.state = movement_msgs.msg.HumanoidStateMsg()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.x.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.x.data))
      length = len(self.x.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.x.bins))
      _x = self
      buff.write(_get_struct_17d().pack(_x.x.freq, _x.x.amp, _x.x.mean, _x.x.integral, _x.x.freqRef, _x.x.freqRange, _x.x.ampRef, _x.x.ampRange, _x.x.meanRef, _x.x.meanRange, _x.x.freqPerf, _x.x.ampPerf, _x.x.meanPerf, _x.x.wFreq, _x.x.wAmp, _x.x.wMean, _x.x.perf))
      length = len(self.y.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.y.data))
      length = len(self.y.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.y.bins))
      _x = self
      buff.write(_get_struct_17d().pack(_x.y.freq, _x.y.amp, _x.y.mean, _x.y.integral, _x.y.freqRef, _x.y.freqRange, _x.y.ampRef, _x.y.ampRange, _x.y.meanRef, _x.y.meanRange, _x.y.freqPerf, _x.y.ampPerf, _x.y.meanPerf, _x.y.wFreq, _x.y.wAmp, _x.y.wMean, _x.y.perf))
      length = len(self.z.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.z.data))
      length = len(self.z.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.z.bins))
      _x = self
      buff.write(_get_struct_17d().pack(_x.z.freq, _x.z.amp, _x.z.mean, _x.z.integral, _x.z.freqRef, _x.z.freqRange, _x.z.ampRef, _x.z.ampRange, _x.z.meanRef, _x.z.meanRange, _x.z.freqPerf, _x.z.ampPerf, _x.z.meanPerf, _x.z.wFreq, _x.z.wAmp, _x.z.wMean, _x.z.perf))
      length = len(self.rFoot.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.rFoot.data))
      length = len(self.rFoot.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.rFoot.bins))
      _x = self
      buff.write(_get_struct_17d().pack(_x.rFoot.freq, _x.rFoot.amp, _x.rFoot.mean, _x.rFoot.integral, _x.rFoot.freqRef, _x.rFoot.freqRange, _x.rFoot.ampRef, _x.rFoot.ampRange, _x.rFoot.meanRef, _x.rFoot.meanRange, _x.rFoot.freqPerf, _x.rFoot.ampPerf, _x.rFoot.meanPerf, _x.rFoot.wFreq, _x.rFoot.wAmp, _x.rFoot.wMean, _x.rFoot.perf))
      length = len(self.lFoot.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.lFoot.data))
      length = len(self.lFoot.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.lFoot.bins))
      _x = self
      buff.write(_get_struct_17d().pack(_x.lFoot.freq, _x.lFoot.amp, _x.lFoot.mean, _x.lFoot.integral, _x.lFoot.freqRef, _x.lFoot.freqRange, _x.lFoot.ampRef, _x.lFoot.ampRange, _x.lFoot.meanRef, _x.lFoot.meanRange, _x.lFoot.freqPerf, _x.lFoot.ampPerf, _x.lFoot.meanPerf, _x.lFoot.wFreq, _x.lFoot.wAmp, _x.lFoot.wMean, _x.lFoot.perf))
      length = len(self.force)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.force))
      length = len(self.torque3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.torque3))
      length = len(self.torque4)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.torque4))
      length = len(self.torqueF)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.torqueF))
      length = len(self.imu)
      buff.write(_struct_I.pack(length))
      for val1 in self.imu:
        _v1 = val1.header
        _x = _v1.seq
        buff.write(_get_struct_I().pack(_x))
        _v2 = _v1.stamp
        _x = _v2
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v1.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v3 = val1.orientation
        _x = _v3
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        buff.write(_get_struct_9d().pack(*val1.orientation_covariance))
        _v4 = val1.angular_velocity
        _x = _v4
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        buff.write(_get_struct_9d().pack(*val1.angular_velocity_covariance))
        _v5 = val1.linear_acceleration
        _x = _v5
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        buff.write(_get_struct_9d().pack(*val1.linear_acceleration_covariance))
      _x = self
      buff.write(_get_struct_10d().pack(_x.perf, _x.df, _x.state.angX, _x.state.angY, _x.state.gyroX, _x.state.gyroY, _x.state.gyroZ, _x.state.accX, _x.state.accY, _x.state.accZ))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.x is None:
        self.x = movement_msgs.msg.PerformanceMsg()
      if self.y is None:
        self.y = movement_msgs.msg.PerformanceMsg()
      if self.z is None:
        self.z = movement_msgs.msg.PerformanceMsg()
      if self.rFoot is None:
        self.rFoot = movement_msgs.msg.PerformanceMsg()
      if self.lFoot is None:
        self.lFoot = movement_msgs.msg.PerformanceMsg()
      if self.imu is None:
        self.imu = None
      if self.state is None:
        self.state = movement_msgs.msg.HumanoidStateMsg()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.x.data = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.x.bins = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.x.freq, _x.x.amp, _x.x.mean, _x.x.integral, _x.x.freqRef, _x.x.freqRange, _x.x.ampRef, _x.x.ampRange, _x.x.meanRef, _x.x.meanRange, _x.x.freqPerf, _x.x.ampPerf, _x.x.meanPerf, _x.x.wFreq, _x.x.wAmp, _x.x.wMean, _x.x.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.y.data = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.y.bins = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.y.freq, _x.y.amp, _x.y.mean, _x.y.integral, _x.y.freqRef, _x.y.freqRange, _x.y.ampRef, _x.y.ampRange, _x.y.meanRef, _x.y.meanRange, _x.y.freqPerf, _x.y.ampPerf, _x.y.meanPerf, _x.y.wFreq, _x.y.wAmp, _x.y.wMean, _x.y.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.z.data = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.z.bins = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.z.freq, _x.z.amp, _x.z.mean, _x.z.integral, _x.z.freqRef, _x.z.freqRange, _x.z.ampRef, _x.z.ampRange, _x.z.meanRef, _x.z.meanRange, _x.z.freqPerf, _x.z.ampPerf, _x.z.meanPerf, _x.z.wFreq, _x.z.wAmp, _x.z.wMean, _x.z.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.rFoot.data = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.rFoot.bins = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.rFoot.freq, _x.rFoot.amp, _x.rFoot.mean, _x.rFoot.integral, _x.rFoot.freqRef, _x.rFoot.freqRange, _x.rFoot.ampRef, _x.rFoot.ampRange, _x.rFoot.meanRef, _x.rFoot.meanRange, _x.rFoot.freqPerf, _x.rFoot.ampPerf, _x.rFoot.meanPerf, _x.rFoot.wFreq, _x.rFoot.wAmp, _x.rFoot.wMean, _x.rFoot.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.lFoot.data = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.lFoot.bins = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.lFoot.freq, _x.lFoot.amp, _x.lFoot.mean, _x.lFoot.integral, _x.lFoot.freqRef, _x.lFoot.freqRange, _x.lFoot.ampRef, _x.lFoot.ampRange, _x.lFoot.meanRef, _x.lFoot.meanRange, _x.lFoot.freqPerf, _x.lFoot.ampPerf, _x.lFoot.meanPerf, _x.lFoot.wFreq, _x.lFoot.wAmp, _x.lFoot.wMean, _x.lFoot.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.force = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torque3 = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torque4 = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torqueF = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.imu = []
      for i in range(0, length):
        val1 = sensor_msgs.msg.Imu()
        _v6 = val1.header
        start = end
        end += 4
        (_v6.seq,) = _get_struct_I().unpack(str[start:end])
        _v7 = _v6.stamp
        _x = _v7
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v6.frame_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v6.frame_id = str[start:end]
        _v8 = val1.orientation
        _x = _v8
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        start = end
        end += 72
        val1.orientation_covariance = _get_struct_9d().unpack(str[start:end])
        _v9 = val1.angular_velocity
        _x = _v9
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 72
        val1.angular_velocity_covariance = _get_struct_9d().unpack(str[start:end])
        _v10 = val1.linear_acceleration
        _x = _v10
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 72
        val1.linear_acceleration_covariance = _get_struct_9d().unpack(str[start:end])
        self.imu.append(val1)
      _x = self
      start = end
      end += 80
      (_x.perf, _x.df, _x.state.angX, _x.state.angY, _x.state.gyroX, _x.state.gyroY, _x.state.gyroZ, _x.state.accX, _x.state.accY, _x.state.accZ,) = _get_struct_10d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.x.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.x.data.tostring())
      length = len(self.x.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.x.bins.tostring())
      _x = self
      buff.write(_get_struct_17d().pack(_x.x.freq, _x.x.amp, _x.x.mean, _x.x.integral, _x.x.freqRef, _x.x.freqRange, _x.x.ampRef, _x.x.ampRange, _x.x.meanRef, _x.x.meanRange, _x.x.freqPerf, _x.x.ampPerf, _x.x.meanPerf, _x.x.wFreq, _x.x.wAmp, _x.x.wMean, _x.x.perf))
      length = len(self.y.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.y.data.tostring())
      length = len(self.y.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.y.bins.tostring())
      _x = self
      buff.write(_get_struct_17d().pack(_x.y.freq, _x.y.amp, _x.y.mean, _x.y.integral, _x.y.freqRef, _x.y.freqRange, _x.y.ampRef, _x.y.ampRange, _x.y.meanRef, _x.y.meanRange, _x.y.freqPerf, _x.y.ampPerf, _x.y.meanPerf, _x.y.wFreq, _x.y.wAmp, _x.y.wMean, _x.y.perf))
      length = len(self.z.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.z.data.tostring())
      length = len(self.z.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.z.bins.tostring())
      _x = self
      buff.write(_get_struct_17d().pack(_x.z.freq, _x.z.amp, _x.z.mean, _x.z.integral, _x.z.freqRef, _x.z.freqRange, _x.z.ampRef, _x.z.ampRange, _x.z.meanRef, _x.z.meanRange, _x.z.freqPerf, _x.z.ampPerf, _x.z.meanPerf, _x.z.wFreq, _x.z.wAmp, _x.z.wMean, _x.z.perf))
      length = len(self.rFoot.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.rFoot.data.tostring())
      length = len(self.rFoot.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.rFoot.bins.tostring())
      _x = self
      buff.write(_get_struct_17d().pack(_x.rFoot.freq, _x.rFoot.amp, _x.rFoot.mean, _x.rFoot.integral, _x.rFoot.freqRef, _x.rFoot.freqRange, _x.rFoot.ampRef, _x.rFoot.ampRange, _x.rFoot.meanRef, _x.rFoot.meanRange, _x.rFoot.freqPerf, _x.rFoot.ampPerf, _x.rFoot.meanPerf, _x.rFoot.wFreq, _x.rFoot.wAmp, _x.rFoot.wMean, _x.rFoot.perf))
      length = len(self.lFoot.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.lFoot.data.tostring())
      length = len(self.lFoot.bins)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.lFoot.bins.tostring())
      _x = self
      buff.write(_get_struct_17d().pack(_x.lFoot.freq, _x.lFoot.amp, _x.lFoot.mean, _x.lFoot.integral, _x.lFoot.freqRef, _x.lFoot.freqRange, _x.lFoot.ampRef, _x.lFoot.ampRange, _x.lFoot.meanRef, _x.lFoot.meanRange, _x.lFoot.freqPerf, _x.lFoot.ampPerf, _x.lFoot.meanPerf, _x.lFoot.wFreq, _x.lFoot.wAmp, _x.lFoot.wMean, _x.lFoot.perf))
      length = len(self.force)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.force.tostring())
      length = len(self.torque3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.torque3.tostring())
      length = len(self.torque4)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.torque4.tostring())
      length = len(self.torqueF)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.torqueF.tostring())
      length = len(self.imu)
      buff.write(_struct_I.pack(length))
      for val1 in self.imu:
        _v11 = val1.header
        _x = _v11.seq
        buff.write(_get_struct_I().pack(_x))
        _v12 = _v11.stamp
        _x = _v12
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v11.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v13 = val1.orientation
        _x = _v13
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        buff.write(val1.orientation_covariance.tostring())
        _v14 = val1.angular_velocity
        _x = _v14
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        buff.write(val1.angular_velocity_covariance.tostring())
        _v15 = val1.linear_acceleration
        _x = _v15
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        buff.write(val1.linear_acceleration_covariance.tostring())
      _x = self
      buff.write(_get_struct_10d().pack(_x.perf, _x.df, _x.state.angX, _x.state.angY, _x.state.gyroX, _x.state.gyroY, _x.state.gyroZ, _x.state.accX, _x.state.accY, _x.state.accZ))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.x is None:
        self.x = movement_msgs.msg.PerformanceMsg()
      if self.y is None:
        self.y = movement_msgs.msg.PerformanceMsg()
      if self.z is None:
        self.z = movement_msgs.msg.PerformanceMsg()
      if self.rFoot is None:
        self.rFoot = movement_msgs.msg.PerformanceMsg()
      if self.lFoot is None:
        self.lFoot = movement_msgs.msg.PerformanceMsg()
      if self.imu is None:
        self.imu = None
      if self.state is None:
        self.state = movement_msgs.msg.HumanoidStateMsg()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.x.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.x.bins = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.x.freq, _x.x.amp, _x.x.mean, _x.x.integral, _x.x.freqRef, _x.x.freqRange, _x.x.ampRef, _x.x.ampRange, _x.x.meanRef, _x.x.meanRange, _x.x.freqPerf, _x.x.ampPerf, _x.x.meanPerf, _x.x.wFreq, _x.x.wAmp, _x.x.wMean, _x.x.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.y.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.y.bins = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.y.freq, _x.y.amp, _x.y.mean, _x.y.integral, _x.y.freqRef, _x.y.freqRange, _x.y.ampRef, _x.y.ampRange, _x.y.meanRef, _x.y.meanRange, _x.y.freqPerf, _x.y.ampPerf, _x.y.meanPerf, _x.y.wFreq, _x.y.wAmp, _x.y.wMean, _x.y.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.z.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.z.bins = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.z.freq, _x.z.amp, _x.z.mean, _x.z.integral, _x.z.freqRef, _x.z.freqRange, _x.z.ampRef, _x.z.ampRange, _x.z.meanRef, _x.z.meanRange, _x.z.freqPerf, _x.z.ampPerf, _x.z.meanPerf, _x.z.wFreq, _x.z.wAmp, _x.z.wMean, _x.z.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.rFoot.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.rFoot.bins = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.rFoot.freq, _x.rFoot.amp, _x.rFoot.mean, _x.rFoot.integral, _x.rFoot.freqRef, _x.rFoot.freqRange, _x.rFoot.ampRef, _x.rFoot.ampRange, _x.rFoot.meanRef, _x.rFoot.meanRange, _x.rFoot.freqPerf, _x.rFoot.ampPerf, _x.rFoot.meanPerf, _x.rFoot.wFreq, _x.rFoot.wAmp, _x.rFoot.wMean, _x.rFoot.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.lFoot.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.lFoot.bins = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.lFoot.freq, _x.lFoot.amp, _x.lFoot.mean, _x.lFoot.integral, _x.lFoot.freqRef, _x.lFoot.freqRange, _x.lFoot.ampRef, _x.lFoot.ampRange, _x.lFoot.meanRef, _x.lFoot.meanRange, _x.lFoot.freqPerf, _x.lFoot.ampPerf, _x.lFoot.meanPerf, _x.lFoot.wFreq, _x.lFoot.wAmp, _x.lFoot.wMean, _x.lFoot.perf,) = _get_struct_17d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.force = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torque3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torque4 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.torqueF = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.imu = []
      for i in range(0, length):
        val1 = sensor_msgs.msg.Imu()
        _v16 = val1.header
        start = end
        end += 4
        (_v16.seq,) = _get_struct_I().unpack(str[start:end])
        _v17 = _v16.stamp
        _x = _v17
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v16.frame_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v16.frame_id = str[start:end]
        _v18 = val1.orientation
        _x = _v18
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        start = end
        end += 72
        val1.orientation_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
        _v19 = val1.angular_velocity
        _x = _v19
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 72
        val1.angular_velocity_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
        _v20 = val1.linear_acceleration
        _x = _v20
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 72
        val1.linear_acceleration_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
        self.imu.append(val1)
      _x = self
      start = end
      end += 80
      (_x.perf, _x.df, _x.state.angX, _x.state.angY, _x.state.gyroX, _x.state.gyroY, _x.state.gyroZ, _x.state.accX, _x.state.accY, _x.state.accZ,) = _get_struct_10d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_10d = None
def _get_struct_10d():
    global _struct_10d
    if _struct_10d is None:
        _struct_10d = struct.Struct("<10d")
    return _struct_10d
_struct_17d = None
def _get_struct_17d():
    global _struct_17d
    if _struct_17d is None:
        _struct_17d = struct.Struct("<17d")
    return _struct_17d
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_9d = None
def _get_struct_9d():
    global _struct_9d
    if _struct_9d is None:
        _struct_9d = struct.Struct("<9d")
    return _struct_9d
